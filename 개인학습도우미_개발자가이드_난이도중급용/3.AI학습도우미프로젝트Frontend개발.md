# Day 3: Frontend 개발 (AI 채팅 인터페이스)

## 산출물 1: React 프로젝트 구조 (AI 최적화)

```
frontend/
├── public/
│   ├── index.html
│   ├── manifest.json
│   └── favicon.ico
├── src/
│   ├── components/
│   │   ├── common/
│   │   │   ├── Layout.jsx
│   │   │   ├── Header.jsx
│   │   │   ├── Sidebar.jsx
│   │   │   ├── LoadingSpinner.jsx
│   │   │   └── ErrorBoundary.jsx
│   │   ├── auth/
│   │   │   ├── LoginForm.jsx
│   │   │   └── RegisterForm.jsx
│   │   ├── content/
│   │   │   ├── ContentUpload.jsx
│   │   │   ├── ContentList.jsx
│   │   │   └── ContentCard.jsx
│   │   ├── chat/                        #  AI 채팅 컴포넌트
│   │   │   ├── ChatInterface.jsx
│   │   │   ├── ChatMessage.jsx
│   │   │   ├── ChatInput.jsx
│   │   │   ├── ChatHistory.jsx
│   │   │   ├── TypingIndicator.jsx
│   │   │   └── FeedbackButtons.jsx
│   │   ├── quiz/                        #  퀴즈 컴포넌트
│   │   │   ├── QuizGenerator.jsx
│   │   │   ├── QuizCard.jsx
│   │   │   └── QuizResult.jsx
│   │   └── dashboard/
│   │       ├── Dashboard.jsx
│   │       ├── ProgressChart.jsx
│   │       └── StatisticsCard.jsx
│   ├── hooks/                           #  커스텀 훅
│   │   ├── useChat.js
│   │   ├── useWebSocket.js
│   │   ├── useFileUpload.js
│   │   └── useLocalStorage.js
│   ├── services/
│   │   ├── api.js
│   │   ├── authService.js
│   │   ├── contentService.js
│   │   ├── chatService.js               #  채팅 서비스
│   │   └── aiService.js                 #  AI 서비스
│   ├── store/
│   │   ├── index.js
│   │   ├── slices/
│   │   │   ├── authSlice.js
│   │   │   ├── contentSlice.js
│   │   │   ├── chatSlice.js             #  채팅 상태
│   │   │   └── uiSlice.js
│   │   └── middleware/
│   │       └── apiMiddleware.js
│   ├── utils/
│   │   ├── constants.js
│   │   ├── helpers.js
│   │   ├── dateUtils.js
│   │   └── chatUtils.js                 #  채팅 유틸리티
│   ├── styles/
│   │   ├── globals.css
│   │   ├── components/
│   │   └── themes/
│   ├── pages/
│   │   ├── Login.jsx
│   │   ├── Dashboard.jsx
│   │   ├── ContentManagement.jsx
│   │   ├── ChatPage.jsx                 #  채팅 페이지
│   │   └── Profile.jsx
│   ├── App.jsx
│   ├── index.js
│   └── setupTests.js
├── package.json
├── tailwind.config.js
└── Dockerfile
```

## 산출물 2: AI 채팅 서비스

### chatService.js
```javascript
import api from './api';

class ChatService {
  constructor() {
    this.baseURL = '/api/ai';
  }

  // AI 질문하기
  async sendMessage(question, contentId = null, useRag = true) {
    try {
      const response = await api.post(`${this.baseURL}/chat`, {
        question,
        contentId,
        useRag
      });
      return response.data;
    } catch (error) {
      console.error('메시지 전송 실패:', error);
      throw this.handleError(error);
    }
  }

  // 채팅 히스토리 조회
  async getChatHistory(contentId = null, page = 0, size = 20) {
    try {
      const params = { page, size };
      if (contentId) params.contentId = contentId;
      
      const response = await api.get(`${this.baseURL}/chat/history`, { params });
      return response.data;
    } catch (error) {
      console.error('채팅 히스토리 조회 실패:', error);
      throw this.handleError(error);
    }
  }

  // 피드백 제출
  async submitFeedback(chatId, feedback) {
    try {
      const response = await api.post(`${this.baseURL}/chat/${chatId}/feedback`, {
        feedback
      });
      return response.data;
    } catch (error) {
      console.error('피드백 제출 실패:', error);
      throw this.handleError(error);
    }
  }

  // 퀴즈 생성
  async generateQuiz(contentId, difficulty = 'MEDIUM', questionCount = 5) {
    try {
      const response = await api.post(`${this.baseURL}/quiz/generate`, {
        contentId,
        difficulty,
        questionCount
      });
      return response.data;
    } catch (error) {
      console.error('퀴즈 생성 실패:', error);
      throw this.handleError(error);
    }
  }

  // 학습 추천 조회
  async getRecommendations(contentId = null) {
    try {
      const params = contentId ? { contentId } : {};
      const response = await api.get(`${this.baseURL}/recommendations`, { params });
      return response.data;
    } catch (error) {
      console.error('추천 조회 실패:', error);
      throw this.handleError(error);
    }
  }

  handleError(error) {
    if (error.response) {
      const { status, data } = error.response;
      switch (status) {
        case 503:
          return new Error('AI 서비스가 일시적으로 사용할 수 없습니다. 잠시 후 다시 시도해주세요.');
        case 502:
          return new Error('AI 서비스 연결에 문제가 있습니다.');
        case 429:
          return new Error('요청이 너무 많습니다. 잠시 후 다시 시도해주세요.');
        default:
          return new Error(data?.message || '알 수 없는 오류가 발생했습니다.');
      }
    }
    return new Error('네트워크 연결을 확인해주세요.');
  }
}

export default new ChatService();
```

### aiService.js
```javascript
import api from './api';

class AIService {
  constructor() {
    this.baseURL = '/api/ai';
  }

  // 스트리밍 채팅 (Server-Sent Events)
  async *streamChat(question, contentId = null, useRag = true) {
    try {
      const response = await fetch(`${api.defaults.baseURL}${this.baseURL}/chat/stream`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({ question, contentId, useRag })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(6));
              yield data;
            } catch (e) {
              console.warn('JSON 파싱 실패:', line);
            }
          }
        }
      }
    } catch (error) {
      console.error('스트리밍 채팅 오류:', error);
      throw error;
    }
  }

  // 실시간 신뢰도 계산
  calculateConfidenceColor(confidence) {
    if (confidence >= 0.8) return 'text-green-600';
    if (confidence >= 0.6) return 'text-yellow-600';
    if (confidence >= 0.4) return 'text-orange-600';
    return 'text-red-600';
  }

  // 메시지 타입 분류
  classifyMessageType(message) {
    const questionWords = ['무엇', '어떻게', '왜', '언제', '어디서', '누가'];
    const hasQuestionWord = questionWords.some(word => message.includes(word));
    const hasQuestionMark = message.includes('?');
    
    if (hasQuestionWord || hasQuestionMark) {
      return 'question';
    }
    
    if (message.includes('요약') || message.includes('정리')) {
      return 'summary';
    }
    
    if (message.includes('퀴즈') || message.includes('문제')) {
      return 'quiz';
    }
    
    return 'general';
  }

  // 응답 포맷팅
  formatResponse(response) {
    const { answer, confidence, sources = [] } = response;
    
    return {
      content: answer,
      confidence: Math.round(confidence * 100),
      confidenceColor: this.calculateConfidenceColor(confidence),
      sources: sources.slice(0, 3), // 최대 3개 소스만 표시
      timestamp: new Date().toISOString()
    };
  }
}

export default new AIService();
```

## 산출물 3: Redux 상태 관리

### chatSlice.js
```javascript
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import chatService from '../services/chatService';
import aiService from '../services/aiService';

// 비동기 액션들
export const sendMessage = createAsyncThunk(
  'chat/sendMessage',
  async ({ question, contentId, useRag }, { rejectWithValue }) => {
    try {
      const response = await chatService.sendMessage(question, contentId, useRag);
      return aiService.formatResponse(response.data);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const loadChatHistory = createAsyncThunk(
  'chat/loadHistory',
  async ({ contentId, page = 0 }, { rejectWithValue }) => {
    try {
      const response = await chatService.getChatHistory(contentId, page);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const submitFeedback = createAsyncThunk(
  'chat/submitFeedback',
  async ({ chatId, feedback }, { rejectWithValue }) => {
    try {
      await chatService.submitFeedback(chatId, feedback);
      return { chatId, feedback };
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const initialState = {
  messages: [],
  history: [],
  currentContentId: null,
  isLoading: false,
  isTyping: false,
  error: null,
  settings: {
    useRag: true,
    autoScroll: true,
    showSources: true,
    showConfidence: true
  },
  statistics: {
    totalMessages: 0,
    averageConfidence: 0,
    totalResponseTime: 0
  }
};

const chatSlice = createSlice({
  name: 'chat',
  initialState,
  reducers: {
    addUserMessage: (state, action) => {
      const message = {
        id: Date.now(),
        type: 'user',
        content: action.payload.content,
        timestamp: new Date().toISOString(),
        contentId: action.payload.contentId
      };
      state.messages.push(message);
    },

    addTypingIndicator: (state) => {
      state.isTyping = true;
    },

    removeTypingIndicator: (state) => {
      state.isTyping = false;
    },

    setCurrentContent: (state, action) => {
      state.currentContentId = action.payload;
      state.messages = []; // 새 콘텐츠 선택 시 메시지 초기화
    },

    updateSettings: (state, action) => {
      state.settings = { ...state.settings, ...action.payload };
    },

    clearMessages: (state) => {
      state.messages = [];
      state.error = null;
    },

    clearError: (state) => {
      state.error = null;
    },

    updateMessageFeedback: (state, action) => {
      const { messageId, feedback } = action.payload;
      const message = state.messages.find(m => m.id === messageId);
      if (message) {
        message.feedback = feedback;
      }
    }
  },

  extraReducers: (builder) => {
    builder
      // sendMessage
      .addCase(sendMessage.pending, (state) => {
        state.isLoading = true;
        state.isTyping = true;
        state.error = null;
      })
      .addCase(sendMessage.fulfilled, (state, action) => {
        state.isLoading = false;
        state.isTyping = false;
        
        const botMessage = {
          id: Date.now() + 1,
          type: 'bot',
          ...action.payload,
          timestamp: new Date().toISOString()
        };
        
        state.messages.push(botMessage);
        
        // 통계 업데이트
        state.statistics.totalMessages += 1;
        state.statistics.averageConfidence = 
          (state.statistics.averageConfidence + action.payload.confidence) / 2;
      })
      .addCase(sendMessage.rejected, (state, action) => {
        state.isLoading = false;
        state.isTyping = false;
        state.error = action.payload;
        
        // 오류 메시지 추가
        const errorMessage = {
          id: Date.now() + 1,
          type: 'error',
          content: action.payload,
          timestamp: new Date().toISOString()
        };
        state.messages.push(errorMessage);
      })

      // loadChatHistory
      .addCase(loadChatHistory.fulfilled, (state, action) => {
        state.history = action.payload;
      })

      // submitFeedback
      .addCase(submitFeedback.fulfilled, (state, action) => {
        const { chatId, feedback } = action.payload;
        const message = state.messages.find(m => m.chatId === chatId);
        if (message) {
          message.feedback = feedback;
        }
      });
  }
});

export const {
  addUserMessage,
  addTypingIndicator,
  removeTypingIndicator,
  setCurrentContent,
  updateSettings,
  clearMessages,
  clearError,
  updateMessageFeedback
} = chatSlice.actions;

export default chatSlice.reducer;
```

## 산출물 4: 커스텀 훅

### useChat.js
```javascript
import { useState, useCallback, useRef, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { 
  sendMessage, 
  addUserMessage, 
  addTypingIndicator,
  removeTypingIndicator,
  setCurrentContent,
  clearMessages 
} from '../store/slices/chatSlice';
import aiService from '../services/aiService';

export const useChat = (contentId = null) => {
  const dispatch = useDispatch();
  const chatState = useSelector(state => state.chat);
  const messagesEndRef = useRef(null);
  const [isStreaming, setIsStreaming] = useState(false);

  const { messages, isLoading, isTyping, error, settings } = chatState;

  // 자동 스크롤
  const scrollToBottom = useCallback(() => {
    if (settings.autoScroll && messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [settings.autoScroll]);

  useEffect(() => {
    scrollToBottom();
  }, [messages, isTyping, scrollToBottom]);

  // 콘텐츠 변경
  const selectContent = useCallback((newContentId) => {
    dispatch(setCurrentContent(newContentId));
  }, [dispatch]);

  // 메시지 전송 (일반)
  const sendChatMessage = useCallback(async (question) => {
    if (!question.trim()) return;

    dispatch(addUserMessage({ 
      content: question, 
      contentId: contentId || chatState.currentContentId 
    }));

    dispatch(sendMessage({
      question,
      contentId: contentId || chatState.currentContentId,
      useRag: settings.useRag
    }));
  }, [dispatch, contentId, chatState.currentContentId, settings.useRag]);

  // 스트리밍 메시지 전송
  const sendStreamingMessage = useCallback(async (question) => {
    if (!question.trim() || isStreaming) return;

    dispatch(addUserMessage({ 
      content: question, 
      contentId: contentId || chatState.currentContentId 
    }));

    setIsStreaming(true);
    dispatch(addTypingIndicator());

    try {
      let accumulatedAnswer = '';
      const botMessageId = Date.now() + 1;
      
      // 임시 봇 메시지 추가
      const tempBotMessage = {
        id: botMessageId,
        type: 'bot',
        content: '',
        confidence: 0,
        sources: [],
        timestamp: new Date().toISOString(),
        isStreaming: true
      };

      dispatch({
        type: 'chat/addBotMessage',
        payload: tempBotMessage
      });

      // 스트리밍 응답 처리
      for await (const chunk of aiService.streamChat(
        question, 
        contentId || chatState.currentContentId, 
        settings.useRag
      )) {
        if (chunk.type === 'content') {
          accumulatedAnswer += chunk.data;
          
          // 실시간 업데이트
          dispatch({
            type: 'chat/updateStreamingMessage',
            payload: {
              id: botMessageId,
              content: accumulatedAnswer
            }
          });
        } else if (chunk.type === 'complete') {
          // 스트리밍 완료
          dispatch({
            type: 'chat/completeStreamingMessage',
            payload: {
              id: botMessageId,
              ...chunk.data,
              isStreaming: false
            }
          });
        }
      }
    } catch (error) {
      console.error('스트리밍 오류:', error);
      dispatch({
        type: 'chat/addErrorMessage',
        payload: {
          content: '메시지 전송 중 오류가 발생했습니다.',
          timestamp: new Date().toISOString()
        }
      });
    } finally {
      setIsStreaming(false);
      dispatch(removeTypingIndicator());
    }
  }, [dispatch, contentId, chatState.currentContentId, settings.useRag, isStreaming]);

  // 대화 초기화
  const clearChat = useCallback(() => {
    dispatch(clearMessages());
  }, [dispatch]);

  // 메시지 타입 분류 및 적절한 응답
  const sendSmartMessage = useCallback(async (question) => {
    const messageType = aiService.classifyMessageType(question);
    
    switch (messageType) {
      case 'quiz':
        // 퀴즈 생성 로직
        break;
      case 'summary':
        // 요약 로직
        break;
      default:
        await sendChatMessage(question);
    }
  }, [sendChatMessage]);

  return {
    // 상태
    messages,
    isLoading,
    isTyping,
    isStreaming,
    error,
    settings,
    messagesEndRef,

    // 액션
    sendMessage: sendChatMessage,
    sendStreamingMessage,
    sendSmartMessage,
    selectContent,
    clearChat,
    scrollToBottom
  };
};

export default useChat;
```

### useWebSocket.js
```javascript
import { useState, useEffect, useRef, useCallback } from 'react';
import { useDispatch } from 'react-redux';

export const useWebSocket = (url, options = {}) => {
  const [connectionStatus, setConnectionStatus] = useState('Connecting');
  const [lastMessage, setLastMessage] = useState(null);
  const [messageHistory, setMessageHistory] = useState([]);
  
  const ws = useRef(null);
  const dispatch = useDispatch();
  
  const {
    onOpen,
    onClose,
    onMessage,
    onError,
    reconnectAttempts = 5,
    reconnectInterval = 3000,
    shouldReconnect = true
  } = options;

  const connect = useCallback(() => {
    try {
      ws.current = new WebSocket(url);
      
      ws.current.onopen = (event) => {
        setConnectionStatus('Connected');
        onOpen?.(event);
      };
      
      ws.current.onclose = (event) => {
        setConnectionStatus('Disconnected');
        onClose?.(event);
        
        if (shouldReconnect && reconnectAttempts > 0) {
          setTimeout(() => {
            connect();
          }, reconnectInterval);
        }
      };
      
      ws.current.onmessage = (event) => {
        const message = JSON.parse(event.data);
        setLastMessage(message);
        setMessageHistory(prev => [...prev, message]);
        onMessage?.(message);
      };
      
      ws.current.onerror = (event) => {
        setConnectionStatus('Error');
        onError?.(event);
      };
      
    } catch (error) {
      console.error('WebSocket 연결 오류:', error);
      setConnectionStatus('Error');
    }
  }, [url, onOpen, onClose, onMessage, onError, shouldReconnect, reconnectAttempts, reconnectInterval]);

  const sendMessage = useCallback((message) => {
    if (ws.current?.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify(message));
    } else {
      console.warn('WebSocket이 연결되지 않았습니다.');
    }
  }, []);

  const disconnect = useCallback(() => {
    if (ws.current) {
      ws.current.close();
    }
  }, []);

  useEffect(() => {
    connect();
    return () => {
      disconnect();
    };
  }, [connect, disconnect]);

  return {
    connectionStatus,
    lastMessage,
    messageHistory,
    sendMessage,
    disconnect,
    connect
  };
};

export default useWebSocket;
```

## 산출물 5: 메인 채팅 컴포넌트

### ChatInterface.jsx
```jsx
import React, { useState, useCallback } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  PaperAirplaneIcon, 
  CogIcon, 
  TrashIcon,
  MicrophoneIcon,
  StopIcon
} from '@heroicons/react/24/outline';

import ChatMessage from './ChatMessage';
import ChatInput from './ChatInput';
import TypingIndicator from './TypingIndicator';
import useChat from '../../hooks/useChat';
import { updateSettings } from '../../store/slices/chatSlice';

const ChatInterface = ({ contentId = null, className = '' }) => {
  const dispatch = useDispatch();
  const { user } = useSelector(state => state.auth);
  const [showSettings, setShowSettings] = useState(false);
  const [isRecording, setIsRecording] = useState(false);

  const {
    messages,
    isLoading,
    isTyping,
    isStreaming,
    error,
    settings,
    messagesEndRef,
    sendMessage,
    sendStreamingMessage,
    clearChat
  } = useChat(contentId);

  const handleSendMessage = useCallback(async (message, options = {}) => {
    if (options.streaming) {
      await sendStreamingMessage(message);
    } else {
      await sendMessage(message);
    }
  }, [sendMessage, sendStreamingMessage]);

  const handleSettingsChange = (newSettings) => {
    dispatch(updateSettings(newSettings));
  };

  const handleVoiceRecord = () => {
    if (isRecording) {
      setIsRecording(false);
      // 음성 인식 중지 로직
    } else {
      setIsRecording(true);
      // 음성 인식 시작 로직
    }
  };

  return (
    <div className={`flex flex-col h-full bg-white dark:bg-gray-900 ${className}`}>
      {/* 헤더 */}
      <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center">
            <span className="text-white font-semibold">AI</span>
          </div>
          <div>
            <h3 className="font-medium text-gray-900 dark:text-white">Smart Learning Assistant</h3>
            <p className="text-sm text-gray-500 dark:text-gray-400">
              {contentId ? '문서 기반 학습' : '일반 대화'}
            </p>
          </div>
        </div>
        
        <div className="flex items-center space-x-2">
          <button
            onClick={() => setShowSettings(!showSettings)}
            className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
          >
            <CogIcon className="w-5 h-5" />
          </button>
          <button
            onClick={clearChat}
            className="p-2 text-gray-500 hover:text-red-600 dark:text-gray-400 dark:hover:text-red-400 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
          >
            <TrashIcon className="w-5 h-5" />
          </button>
        </div>
      </div>

      {/* 설정 패널 */}
      <AnimatePresence>
        {showSettings && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            className="bg-gray-50 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-4"
          >
            <div className="grid grid-cols-2 gap-4">
              <label className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={settings.useRag}
                  onChange={(e) => handleSettingsChange({ useRag: e.target.checked })}
                  className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                />
                <span className="text-sm text-gray-700 dark:text-gray-300">고급 RAG 모드</span>
              </label>
              
              <label className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={settings.showSources}
                  onChange={(e) => handleSettingsChange({ showSources: e.target.checked })}
                  className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                />
                <span className="text-sm text-gray-700 dark:text-gray-300">소스 표시</span>
              </label>
              
              <label className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={settings.showConfidence}
                  onChange={(e) => handleSettingsChange({ showConfidence: e.target.checked })}
                  className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                />
                <span className="text-sm text-gray-700 dark:text-gray-300">신뢰도 표시</span>
              </label>
              
              <label className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={settings.autoScroll}
                  onChange={(e) => handleSettingsChange({ autoScroll: e.target.checked })}
                  className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                />
                <span className="text-sm text-gray-700 dark:text-gray-300">자동 스크롤</span>
              </label>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* 메시지 영역 */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {error && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-3"
          >
            <p className="text-red-700 dark:text-red-400 text-sm">{error}</p>
          </motion.div>
        )}

        {messages.length === 0 ? (
          <div className="text-center py-12">
            <div className="w-16 h-16 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full mx-auto mb-4 flex items-center justify-center">
              <span className="text-white text-xl font-bold">AI</span>
            </div>
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
              안녕하세요! 무엇을 도와드릴까요?
            </h3>
            <p className="text-gray-500 dark:text-gray-400 mb-6">
              학습 자료에 대해 질문하거나 도움이 필요한 내용을 말씀해주세요.
            </p>
            
            {/* 예시 질문들 */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3 max-w-2xl mx-auto">
              {[
                "문서의 주요 내용을 요약해주세요",
                "핵심 개념들을 설명해주세요",
                "이해하기 어려운 부분이 있어요",
                "퀴즈를 만들어주세요"
              ].map((question, index) => (
                <button
                  key={index}
                  onClick={() => handleSendMessage(question)}
                  className="p-3 text-left bg-gray-50 dark:bg-gray-800 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors text-sm text-gray-700 dark:text-gray-300"
                >
                  {question}
                </button>
              ))}
            </div>
          </div>
        ) : (
          <AnimatePresence>
            {messages.map((message) => (
              <ChatMessage
                key={message.id}
                message={message}
                showSources={settings.showSources}
                showConfidence={settings.showConfidence}
                user={user}
              />
            ))}
          </AnimatePresence>
        )}

        {isTyping && <TypingIndicator />}
        <div ref={messagesEndRef} />
      </div>

      {/* 입력 영역 */}
      <div className="border-t border-gray-200 dark:border-gray-700 p-4">
        <ChatInput
          onSendMessage={handleSendMessage}
          isLoading={isLoading || isStreaming}
          onVoiceRecord={handleVoiceRecord}
          isRecording={isRecording}
          placeholder="메시지를 입력하세요..."
        />
      </div>
    </div>
  );
};

export default ChatInterface;
```

### ChatMessage.jsx
```jsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  HandThumbUpIcon, 
  HandThumbDownIcon,
  ClipboardDocumentIcon,
  SpeakerWaveIcon
} from '@heroicons/react/24/outline';
import { 
  HandThumbUpIcon as HandThumbUpSolidIcon, 
  HandThumbDownIcon as HandThumbDownSolidIcon 
} from '@heroicons/react/24/solid';
import { useDispatch } from 'react-redux';
import { submitFeedback } from '../../store/slices/chatSlice';
import FeedbackButtons from './FeedbackButtons';

const ChatMessage = ({ message, showSources, showConfidence, user }) => {
  const dispatch = useDispatch();
  const [isExpanded, setIsExpanded] = useState(false);
  const [copied, setCopied] = useState(false);

  const isUser = message.type === 'user';
  const isError = message.type === 'error';
  
  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(message.content);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('복사 실패:', err);
    }
  };

  const handleSpeak = () => {
    if ('speechSynthesis' in window) {
      const utterance = new SpeechSynthesisUtterance(message.content);
      utterance.lang = 'ko-KR';
      speechSynthesis.speak(utterance);
    }
  };

  const handleFeedback = (feedback) => {
    if (message.chatId) {
      dispatch(submitFeedback({ chatId: message.chatId, feedback }));
    }
  };

  const messageVariants = {
    initial: { opacity: 0, y: 20, scale: 0.95 },
    animate: { opacity: 1, y: 0, scale: 1 },
    exit: { opacity: 0, y: -20, scale: 0.95 }
  };

  return (
    <motion.div
      variants={messageVariants}
      initial="initial"
      animate="animate"
      exit="exit"
      className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}
    >
      <div className={`max-w-[80%] ${isUser ? 'order-2' : 'order-1'}`}>
        {/* 사용자 정보 */}
        {!isUser && (
          <div className="flex items-center space-x-2 mb-2">
            <div className="w-6 h-6 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center">
              <span className="text-white text-xs font-semibold">AI</span>
            </div>
            <span className="text-xs text-gray-500 dark:text-gray-400">
              Smart Learning Assistant
            </span>
          </div>
        )}

        {/* 메시지 버블 */}
        <div
          className={`relative px-4 py-3 rounded-2xl ${
            isUser
              ? 'bg-blue-600 text-white ml-4'
              : isError
              ? 'bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-400 mr-4'
              : 'bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white mr-4'
          }`}
        >
          {/* 스트리밍 인디케이터 */}
          {message.isStreaming && (
            <div className="absolute -bottom-2 -right-2 w-4 h-4">
              <div className="w-full h-full bg-blue-500 rounded-full animate-pulse"></div>
            </div>
          )}

          {/* 메시지 내용 */}
          <div className="prose prose-sm max-w-none">
            {message.content.length > 500 && !isExpanded ? (
              <>
                <p>{message.content.substring(0, 500)}...</p>
                <button
                  onClick={() => setIsExpanded(true)}
                  className="text-blue-600 dark:text-blue-400 hover:underline text-sm mt-2"
                >
                  더 보기
                </button>
              </>
            ) : (
              <div dangerouslySetInnerHTML={{ 
                __html: message.content.replace(/\n/g, '<br/>') 
              }} />
            )}
          </div>

          {/* 신뢰도 표시 */}
          {!isUser && !isError && showConfidence && message.confidence !== undefined && (
            <div className="mt-3 flex items-center space-x-2">
              <div className="flex items-center space-x-1">
                <div className="w-2 h-2 bg-gray-300 dark:bg-gray-600 rounded-full"></div>
                <span className="text-xs text-gray-500 dark:text-gray-400">
                  신뢰도:
                </span>
                <span className={`text-xs font-medium ${message.confidenceColor || 'text-gray-600'}`}>
                  {message.confidence}%
                </span>
              </div>
            </div>
          )}

          {/* 소스 정보 */}
          {!isUser && !isError && showSources && message.sources && message.sources.length > 0 && (
            <div className="mt-3 border-t border-gray-200 dark:border-gray-700 pt-3">
              <div className="text-xs text-gray-500 dark:text-gray-400 mb-2">참고 자료:</div>
              <div className="space-y-1">
                {message.sources.slice(0, 3).map((source, index) => (
                  <div key={index} className="text-xs bg-gray-50 dark:bg-gray-700 rounded p-2">
                    <div className="font-medium text-gray-700 dark:text-gray-300">
                      {source.metadata?.title || `문서 ${index + 1}`}
                    </div>
                    {source.content && (
                      <div className="text-gray-600 dark:text-gray-400 mt-1 truncate">
                        {source.content}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* 액션 버튼들 */}
        {!isUser && !isError && (
          <div className="flex items-center space-x-2 mt-2 ml-2">
            <button
              onClick={handleCopy}
              className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors"
              title="복사"
            >
              <ClipboardDocumentIcon className="w-4 h-4" />
            </button>
            
            <button
              onClick={handleSpeak}
              className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors"
              title="음성으로 듣기"
            >
              <SpeakerWaveIcon className="w-4 h-4" />
            </button>

            <FeedbackButtons
              messageId={message.id}
              currentFeedback={message.feedback}
              onFeedback={handleFeedback}
            />

            {copied && (
              <span className="text-xs text-green-600 dark:text-green-400">복사됨!</span>
            )}
          </div>
        )}

        {/* 타임스탬프 */}
        <div className={`text-xs text-gray-400 mt-1 ${isUser ? 'text-right mr-4' : 'ml-2'}`}>
          {new Date(message.timestamp).toLocaleTimeString('ko-KR', {
            hour: '2-digit',
            minute: '2-digit'
          })}
        </div>
      </div>
    </motion.div>
  );
};

export default ChatMessage;
```

### ChatInput.jsx
```jsx
import React, { useState, useRef, useCallback } from 'react';
import { 
  PaperAirplaneIcon, 
  MicrophoneIcon,
  StopIcon,
  PhotoIcon,
  PaperClipIcon
} from '@heroicons/react/24/outline';
import { motion } from 'framer-motion';

const ChatInput = ({ 
  onSendMessage, 
  isLoading, 
  onVoiceRecord, 
  isRecording, 
  placeholder = "메시지를 입력하세요..." 
}) => {
  const [message, setMessage] = useState('');
  const [isComposing, setIsComposing] = useState(false);
  const textareaRef = useRef(null);
  const fileInputRef = useRef(null);

  const handleSubmit = useCallback((e) => {
    e.preventDefault();
    if (message.trim() && !isLoading) {
      onSendMessage(message.trim());
      setMessage('');
      if (textareaRef.current) {
        textareaRef.current.style.height = 'auto';
      }
    }
  }, [message, isLoading, onSendMessage]);

  const handleKeyDown = useCallback((e) => {
    if (e.key === 'Enter' && !e.shiftKey && !isComposing) {
      e.preventDefault();
      handleSubmit(e);
    }
  }, [handleSubmit, isComposing]);

  const handleTextChange = useCallback((e) => {
    setMessage(e.target.value);
    
    // 자동 높이 조절
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 120)}px`;
    }
  }, []);

  const handleFileUpload = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (e) => {
    const files = Array.from(e.target.files);
    // 파일 업로드 로직 구현
    console.log('업로드할 파일들:', files);
  };

  return (
    <form onSubmit={handleSubmit} className="relative">
      <div className="flex items-end space-x-3 bg-gray-50 dark:bg-gray-800 rounded-2xl p-3">
        {/* 파일 업로드 버튼 */}
        <button
          type="button"
          onClick={handleFileUpload}
          className="flex-shrink-0 p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors"
          title="파일 첨부"
        >
          <PaperClipIcon className="w-5 h-5" />
        </button>

        {/* 텍스트 입력 영역 */}
        <div className="flex-1 relative">
          <textarea
            ref={textareaRef}
            value={message}
            onChange={handleTextChange}
            onKeyDown={handleKeyDown}
            onCompositionStart={() => setIsComposing(true)}
            onCompositionEnd={() => setIsComposing(false)}
            placeholder={placeholder}
            className="w-full resize-none border-0 bg-transparent text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-0 focus:outline-none"
            style={{ minHeight: '20px', maxHeight: '120px' }}
            disabled={isLoading}
            rows={1}
          />
        </div>

        {/* 음성 인식 버튼 */}
        <motion.button
          type="button"
          onClick={onVoiceRecord}
          className={`flex-shrink-0 p-2 transition-colors ${
            isRecording 
              ? 'text-red-600 hover:text-red-700' 
              : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200'
          }`}
          whileTap={{ scale: 0.95 }}
          title={isRecording ? "녹음 중지" : "음성 입력"}
        >
          {isRecording ? (
            <StopIcon className="w-5 h-5" />
          ) : (
            <MicrophoneIcon className="w-5 h-5" />
          )}
        </motion.button>

        {/* 전송 버튼 */}
        <motion.button
          type="submit"
          disabled={!message.trim() || isLoading}
          className={`flex-shrink-0 p-2 rounded-xl transition-all ${
            message.trim() && !isLoading
              ? 'bg-blue-600 text-white hover:bg-blue-700 shadow-md'
              : 'bg-gray-300 dark:bg-gray-600 text-gray-500 dark:text-gray-400 cursor-not-allowed'
          }`}
          whileTap={{ scale: 0.95 }}
          whileHover={{ scale: message.trim() && !isLoading ? 1.05 : 1 }}
        >
          {isLoading ? (
            <div className="w-5 h-5 animate-spin rounded-full border-2 border-white border-t-transparent" />
          ) : (
            <PaperAirplaneIcon className="w-5 h-5" />
          )}
        </motion.button>
      </div>

      {/* 숨겨진 파일 입력 */}
      <input
        ref={fileInputRef}
        type="file"
        multiple
        accept=".pdf,.txt,.docx,.md,.jpg,.jpeg,.png"
        onChange={handleFileChange}
        className="hidden"
      />

      {/* 입력 중 표시 */}
      {isComposing && (
        <div className="absolute -top-8 left-0 bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded text-xs text-gray-600 dark:text-gray-300">
          입력 중...
        </div>
      )}
    </form>
  );
};

export default ChatInput;
```

### TypingIndicator.jsx
```jsx
import React from 'react';
import { motion } from 'framer-motion';

const TypingIndicator = () => {
  const dotVariants = {
    start: { opacity: 0.3 },
    end: { opacity: 1 }
  };

  const containerVariants = {
    start: { transition: { staggerChildren: 0.2 } },
    end: { transition: { staggerChildren: 0.2 } }
  };

  return (
    <div className="flex justify-start">
      <div className="bg-gray-100 dark:bg-gray-800 rounded-2xl px-4 py-3 mr-4">
        <div className="flex items-center space-x-2">
          <div className="w-6 h-6 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center">
            <span className="text-white text-xs font-semibold">AI</span>
          </div>
          <motion.div
            variants={containerVariants}
            initial="start"
            animate="end"
            className="flex space-x-1"
          >
            {[0, 1, 2].map((index) => (
              <motion.div
                key={index}
                variants={dotVariants}
                transition={{
                  duration: 0.6,
                  repeat: Infinity,
                  repeatType: "reverse",
                  ease: "easeInOut"
                }}
                className="w-2 h-2 bg-gray-500 dark:bg-gray-400 rounded-full"
              />
            ))}
          </motion.div>
          <span className="text-sm text-gray-500 dark:text-gray-400">
            AI가 답변을 생성하고 있습니다...
          </span>
        </div>
      </div>
    </div>
  );
};

export default TypingIndicator;
```

### FeedbackButtons.jsx
```jsx
import React from 'react';
import { 
  HandThumbUpIcon, 
  HandThumbDownIcon 
} from '@heroicons/react/24/outline';
import { 
  HandThumbUpIcon as HandThumbUpSolidIcon, 
  HandThumbDownIcon as HandThumbDownSolidIcon 
} from '@heroicons/react/24/solid';
import { motion } from 'framer-motion';

const FeedbackButtons = ({ messageId, currentFeedback, onFeedback }) => {
  const handleFeedback = (feedback) => {
    // 이미 같은 피드백이 선택되었다면 취소
    if (currentFeedback === feedback) {
      onFeedback(null);
    } else {
      onFeedback(feedback);
    }
  };

  return (
    <div className="flex items-center space-x-1">
      <motion.button
        onClick={() => handleFeedback('HELPFUL')}
        className={`p-1 transition-colors ${
          currentFeedback === 'HELPFUL'
            ? 'text-green-600 dark:text-green-400'
            : 'text-gray-400 hover:text-green-600 dark:hover:text-green-400'
        }`}
        whileTap={{ scale: 0.9 }}
        title="도움이 되었습니다"
      >
        {currentFeedback === 'HELPFUL' ? (
          <HandThumbUpSolidIcon className="w-4 h-4" />
        ) : (
          <HandThumbUpIcon className="w-4 h-4" />
        )}
      </motion.button>

      <motion.button
        onClick={() => handleFeedback('NOT_HELPFUL')}
        className={`p-1 transition-colors ${
          currentFeedback === 'NOT_HELPFUL'
            ? 'text-red-600 dark:text-red-400'
            : 'text-gray-400 hover:text-red-600 dark:hover:text-red-400'
        }`}
        whileTap={{ scale: 0.9 }}
        title="도움이 되지 않았습니다"
      >
        {currentFeedback === 'NOT_HELPFUL' ? (
          <HandThumbDownSolidIcon className="w-4 h-4" />
        ) : (
          <HandThumbDownIcon className="w-4 h-4" />
        )}
      </motion.button>
    </div>
  );
};

export default FeedbackButtons;
```

## 산출물 6: 퀴즈 컴포넌트

### QuizGenerator.jsx
```jsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { 
  AcademicCapIcon, 
  ClockIcon, 
  CheckCircleIcon,
  XCircleIcon 
} from '@heroicons/react/24/outline';
import { useDispatch, useSelector } from 'react-redux';
import chatService from '../../services/chatService';

const QuizGenerator = ({ contentId }) => {
  const dispatch = useDispatch();
  const [isGenerating, setIsGenerating] = useState(false);
  const [quiz, setQuiz] = useState(null);
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [userAnswers, setUserAnswers] = useState({});
  const [showResults, setShowResults] = useState(false);
  const [settings, setSettings] = useState({
    difficulty: 'MEDIUM',
    questionCount: 5
  });

  const generateQuiz = async () => {
    setIsGenerating(true);
    try {
      const response = await chatService.generateQuiz(
        contentId, 
        settings.difficulty, 
        settings.questionCount
      );
      setQuiz(response.data);
      setCurrentQuestion(0);
      setUserAnswers({});
      setShowResults(false);
    } catch (error) {
      console.error('퀴즈 생성 실패:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleAnswer = (questionIndex, answer) => {
    setUserAnswers(prev => ({
      ...prev,
      [questionIndex]: answer
    }));
  };

  const calculateScore = () => {
    if (!quiz) return 0;
    
    let correct = 0;
    quiz.questions.forEach((question, index) => {
      if (userAnswers[index] === question.correctAnswer) {
        correct++;
      }
    });
    
    return Math.round((correct / quiz.questions.length) * 100);
  };

  const finishQuiz = () => {
    setShowResults(true);
  };

  if (!quiz && !isGenerating) {
    return (
      <div className="bg-white dark:bg-gray-900 rounded-xl shadow-lg p-6">
        <div className="text-center">
          <AcademicCapIcon className="w-16 h-16 text-blue-600 mx-auto mb-4" />
          <h3 className="text-xl font-semibold text-gray-900 dark:text-white mb-2">
            AI 퀴즈 생성기
          </h3>
          <p className="text-gray-600 dark:text-gray-400 mb-6">
            학습 
    